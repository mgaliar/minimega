{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome \u00b6 This is the documentation for the minimega phenix orchestration tool. Getting Started with phenix \u00b6 Building \u00b6 To build locally, you will need Golang v1.14 and Node v14.2 installed. Once those are installed (if not already), simply run make bin/phenix . If you do not want to install Golang and/or Node locally, you can also use Docker to build phenix (assuming you have Docker installed). Simply run ./build-with-docker.sh and once built, the phenix binary will be available at bin/phenix . See ./build-with-docker.sh -h for usage details. Using \u00b6 The following output results from bin/phenix help : A cli application for ph\u0113nix Usage: phenix [flags] phenix [command] Available Commands: config Configuration file management experiment Experiment management help Help about any command image Virtual disk image management ui Run the phenix UI util Utility commands version print version information vlan Used to manage VLANs vm Virtual machine management Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") -h, --help help for phenix --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/var/log/phenix/error.log\") --log.error-stderr log fatal errors to STDERR (default true) --store.endpoint string endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\") Use \"phenix [command] --help\" for more information about a command. Thanks to viper , it is possible to specify values for all of the global and ui command flags listed above using a configuration file. Global flags set at the command line will override settings in the configuration file. phenix looks for a configuration in the following locations. When run as root (not including sudo): /etc/phenix/config.[yaml|json|toml] When run as regular user (including sudo): $HOME/.config/phenix/config.[yaml|json|toml] /etc/phenix/config.[yaml|json|toml] An example configuration file might look like the following: base-dir: minimega: /tmp/minimega phenix: /phenix log: error-file: /var/log/phenix/error.log error-stderr: true store: endpoint: bolt:///etc/phenix/store.bdb ui: listen-endpoint: 0.0.0.0:3000 jwt-signing-key: abcde12345 log-level: info log-verbose: true logs: phenix-path: /var/log/phenix/phenix.log minimega-path: /var/log/minimega/minimega.log Environment variables can also be used to set global and ui command flags. The environment variables must be prefixed with PHENIX_ , with the rest of the variable matching the flag name with - and . replaced with _ . For example, --store.endpoint becomes PHENIX_STORE_ENDPOINT . Further documentation on the available commands can be found at: config experiment vm image Store \u00b6 The phenix tool uses a key-value data store as the storage service for all of data needed throughout the various capabilities (as opposed to a database). By default it uses bbolt but also supports etcd . bbolt is used by default because it has no external dependencies, but has a limitation of only being accessible on a single machine. Using etcd , on the other hand, allows for users to run phenix on multiple machines and access the same data, but requires etcd be deployed as a separate service. To use etcd , the --store.endpoint global flag should be configured with the URL of the deployed etcd server. For example, --store.endpoint etcd://localhost:2379 .","title":"Welcome"},{"location":"#welcome","text":"This is the documentation for the minimega phenix orchestration tool.","title":"Welcome"},{"location":"#getting-started-with-phenix","text":"","title":"Getting Started with phenix"},{"location":"#building","text":"To build locally, you will need Golang v1.14 and Node v14.2 installed. Once those are installed (if not already), simply run make bin/phenix . If you do not want to install Golang and/or Node locally, you can also use Docker to build phenix (assuming you have Docker installed). Simply run ./build-with-docker.sh and once built, the phenix binary will be available at bin/phenix . See ./build-with-docker.sh -h for usage details.","title":"Building"},{"location":"#using","text":"The following output results from bin/phenix help : A cli application for ph\u0113nix Usage: phenix [flags] phenix [command] Available Commands: config Configuration file management experiment Experiment management help Help about any command image Virtual disk image management ui Run the phenix UI util Utility commands version print version information vlan Used to manage VLANs vm Virtual machine management Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") -h, --help help for phenix --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/var/log/phenix/error.log\") --log.error-stderr log fatal errors to STDERR (default true) --store.endpoint string endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\") Use \"phenix [command] --help\" for more information about a command. Thanks to viper , it is possible to specify values for all of the global and ui command flags listed above using a configuration file. Global flags set at the command line will override settings in the configuration file. phenix looks for a configuration in the following locations. When run as root (not including sudo): /etc/phenix/config.[yaml|json|toml] When run as regular user (including sudo): $HOME/.config/phenix/config.[yaml|json|toml] /etc/phenix/config.[yaml|json|toml] An example configuration file might look like the following: base-dir: minimega: /tmp/minimega phenix: /phenix log: error-file: /var/log/phenix/error.log error-stderr: true store: endpoint: bolt:///etc/phenix/store.bdb ui: listen-endpoint: 0.0.0.0:3000 jwt-signing-key: abcde12345 log-level: info log-verbose: true logs: phenix-path: /var/log/phenix/phenix.log minimega-path: /var/log/minimega/minimega.log Environment variables can also be used to set global and ui command flags. The environment variables must be prefixed with PHENIX_ , with the rest of the variable matching the flag name with - and . replaced with _ . For example, --store.endpoint becomes PHENIX_STORE_ENDPOINT . Further documentation on the available commands can be found at: config experiment vm image","title":"Using"},{"location":"#store","text":"The phenix tool uses a key-value data store as the storage service for all of data needed throughout the various capabilities (as opposed to a database). By default it uses bbolt but also supports etcd . bbolt is used by default because it has no external dependencies, but has a limitation of only being accessible on a single machine. Using etcd , on the other hand, allows for users to run phenix on multiple machines and access the same data, but requires etcd be deployed as a separate service. To use etcd , the --store.endpoint global flag should be configured with the URL of the deployed etcd server. For example, --store.endpoint etcd://localhost:2379 .","title":"Store"},{"location":"apps/","text":"Apps \u00b6 phenix apps provide a means of modifying an experiment topology, cluster networking, hardware-in-the-loop devices, etc. in a layered, scripted, and codified manner. phenix itself includes four (4) default apps that get applied to every experiment by default. In addition to the default apps, it is possible to apply user apps to an experiment using a scenario configuration. Default Apps \u00b6 ntp provides/configures NTP service for experiment serial configures serial interfaces in VM images startup configures minimega startup injections based on OS type vyatta customizes Vyatta routers, including setting interfaces, ACL rules, etc. User Apps \u00b6 phenix user apps are stand-alone executables that phenix shells out to at different stages of the experiment lifecycle ( configure, pre-start, post-start, and cleanup ). When phenix encounters an app in an experiment scenario that isn't a default app, it checks to see if an executable exists in its current PATH in the form of phenix-app-<app name> . If the executable exists, phenix shells out to it, providing the current lifecycle stage as an argument and providing the experiment metadata, spec, and status as a JSON string over STDIN . Note There will be three (3) top-level keys available in the JSON passed to a user app over STDIN : metadata, spec, and status . For the configure and pre-start stages, the status value will be null or otherwise ignored. The spec value will be experiment schema . Tip You can run phenix util app-json <exp name> to see an example of what the JSON that's passed to a user app looks like. The user app can modify the experiment at will, then return the updated JSON over STDOUT and exit with a 0 status. If the user app encounters an error, it can print any error messages to STDERR and exit with a non-zero status to signal to phenix that an error occurred. Note phenix will only process updates to the spec value for the configure and pre-start stages, and will only process updates to the status value for the post-start and cleanup stages. More specifically, it will only process updates to status.apps.<app name> , which can be anything the app wants it to be (e.g. a simple string, an array, or a map/dictionary). Example \u00b6 Below is a very contrived example of a simple user app that changes the disk image used for every node in the experiment topology. Assuming the name of the executable for this app as phenix-app-image-changer , it could be applied to a topology by including a scenario in an experiment that includes an experiment app named image-changer . import json, sys def eprint(*args): print(*args, file=sys.stderr) def main() : if len(sys.argv) != 2: eprint(\"must pass exactly one argument on the command line\") sys.exit(1) raw = sys.stdin.read() if sys.argv[1] != 'pre-start': print(raw) sys.exit(0) exp = json.loads(raw) spec = exp['spec'] for n in spec['topology']['nodes']: for d in n['hardware']['drives']: d['image'] = 'm$.qc2' print(json.dumps(exp))","title":"Apps"},{"location":"apps/#apps","text":"phenix apps provide a means of modifying an experiment topology, cluster networking, hardware-in-the-loop devices, etc. in a layered, scripted, and codified manner. phenix itself includes four (4) default apps that get applied to every experiment by default. In addition to the default apps, it is possible to apply user apps to an experiment using a scenario configuration.","title":"Apps"},{"location":"apps/#default-apps","text":"ntp provides/configures NTP service for experiment serial configures serial interfaces in VM images startup configures minimega startup injections based on OS type vyatta customizes Vyatta routers, including setting interfaces, ACL rules, etc.","title":"Default Apps"},{"location":"apps/#user-apps","text":"phenix user apps are stand-alone executables that phenix shells out to at different stages of the experiment lifecycle ( configure, pre-start, post-start, and cleanup ). When phenix encounters an app in an experiment scenario that isn't a default app, it checks to see if an executable exists in its current PATH in the form of phenix-app-<app name> . If the executable exists, phenix shells out to it, providing the current lifecycle stage as an argument and providing the experiment metadata, spec, and status as a JSON string over STDIN . Note There will be three (3) top-level keys available in the JSON passed to a user app over STDIN : metadata, spec, and status . For the configure and pre-start stages, the status value will be null or otherwise ignored. The spec value will be experiment schema . Tip You can run phenix util app-json <exp name> to see an example of what the JSON that's passed to a user app looks like. The user app can modify the experiment at will, then return the updated JSON over STDOUT and exit with a 0 status. If the user app encounters an error, it can print any error messages to STDERR and exit with a non-zero status to signal to phenix that an error occurred. Note phenix will only process updates to the spec value for the configure and pre-start stages, and will only process updates to the status value for the post-start and cleanup stages. More specifically, it will only process updates to status.apps.<app name> , which can be anything the app wants it to be (e.g. a simple string, an array, or a map/dictionary).","title":"User Apps"},{"location":"apps/#example","text":"Below is a very contrived example of a simple user app that changes the disk image used for every node in the experiment topology. Assuming the name of the executable for this app as phenix-app-image-changer , it could be applied to a topology by including a scenario in an experiment that includes an experiment app named image-changer . import json, sys def eprint(*args): print(*args, file=sys.stderr) def main() : if len(sys.argv) != 2: eprint(\"must pass exactly one argument on the command line\") sys.exit(1) raw = sys.stdin.read() if sys.argv[1] != 'pre-start': print(raw) sys.exit(0) exp = json.loads(raw) spec = exp['spec'] for n in spec['topology']['nodes']: for d in n['hardware']['drives']: d['image'] = 'm$.qc2' print(json.dumps(exp))","title":"Example"},{"location":"configuration/","text":"Configuration Files \u00b6 phenix currently supports six (6) different configuration file types: Topology Scenario Experiment Image User Role Typically, users will create Topology and Scenario configuration files by hand, while the rest will be generated by phenix using available commands. However, it is possible to create all configuration file types by hand if necessary. Configuration files are versioned using a header section based heavily on what Kubernetes does. Each configuration file will have a header section that looks like the following: apiVersion: phenix.sandia.gov/v1 kind: Topology metadata: name: foobar spec: ... In the example above, the kind field represents the type of configuration file (e.g., Topology, Scenario, Image). The apiVersion field represents the version the spec section conforms to (currently there is only v1 for all configuration types), and the spec section will contain the actual details for the configuration type based on the configuration schema. Note that, at least in the header section, keys are camel-case and begin with a lowercase letter, while values are camel-cased but begin with a capital letter. Note Throughout the documentation, we mention creating configurations manually . When we say this, we mean passing a YAML or JSON configuration file of any type to the phenix config create command. Topology \u00b6 The Topology configuration is one of the core configuration types for phenix , as it describes a network topology to be deployed in minimega that can be used by one or more experiments to be executed. A topology is comprised of one or more nodes (which is a VM or container), each including system descriptions and configurations, as well as any networking settings required to connect all of the nodes in a topology together. This configuration becomes the basis for most of the minimega commands later created in the relevant minimega startup script. Default Settings \u00b6 If left unmodified or unset, the following are the default settings for each node: - memory will be set to 512MB - snapshot will be set to true - no network settings will be included Required Values \u00b6 Each topology must have a unique name, which should be lowercase and not include spaces. In addition, each node in the topology must: have a specified type (available types are defined in the schema have a unique hostname have an OS type of linux or windows have a disk image assigned Optional Values \u00b6 Optional values for a node in the topology configuration can include: static network configurations specific memory values (e.g., 1-16GB) specific VCPUs values (e.g., 1-4) additional disk storage file injections labels (typically used by phenix apps) routing ruleset(s) Example \u00b6 A contrived, four node example -- three VMs and a router -- is given below, and is driven by the topology schema described here . apiVersion: phenix.sandia.gov/v1 kind: Topology metadata: name: foobar spec: nodes: - type: VirtualMachine general: hostname: host-00 snapshot: true hardware: os_type: linux drives: - image: ubuntu.qc2 injections: - src: foo/bar/sucka.fish dst: /data/sucka.fish - src: /foo/bar/sucka/fish.sh dst: /data/fish.sh network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.1 mask: 24 gateway: 192.168.10.254 proto: static type: ethernet - name: IF1 vlan: MGMT address: 172.16.10.1 mask: 16 proto: static type: ethernet - type: VirtualMachine general: hostname: host-01 snapshot: true hardware: os_type: linux drives: - image: ubuntu.qc2 network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.2 mask: 24 gateway: 192.168.10.254 proto: static type: ethernet - name: IF1 vlan: MGMT address: 172.16.10.2 mask: 16 proto: static type: ethernet - name: S0 vlan: EXT address: 10.0.0.1 mask: 24 proto: static type: serial udp_port: 8989 baud_rate: 9600 device: /dev/ttyS0 - type: VirtualMachine general: hostname: AD1 snapshot: true hardware: os_type: windows drives: - image: win-svr-2k8.qc2 network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.250 mask: 24 gateway: 192.168.10.254 proto: static type: ethernet - name: IF1 vlan: MGMT address: 172.16.10.3 mask: 16 proto: static type: ethernet - type: Router labels: ntp-server: \"true\" general: hostname: router-00 snapshot: true hardware: os_type: linux drives: - image: vyatta.qc2 network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.254 mask: 24 proto: static type: ethernet ruleset_in: test - name: IF1 vlan: MGMT address: 172.16.10.254 mask: 16 proto: static type: ethernet rulesets: - name: test default: drop rules: - id: 10 action: accept protocol: all source: address: 1.1.1.1 port: 53 Scenario \u00b6 The Scenario configuration is used to define and configure one or more phenix apps ( default or user ) for use on a topology. In this sense, a topology can have one or more scenarios associated with it, but a scenario can only be associated with a single topology. There are two categories of phenix apps that can be configured in a scenario: 1) experiment, and 2) host. A scenario can contain zero or more experiment and/or host apps. Experiment Apps \u00b6 An experiment app is a phenix app that can be applied to experiment topology using a single configuration. For example, a phenix app that adds a minimega tap to all hosts in the cluster or one that injects the same file into every node in the experiment topology would be good candidates for an experiment app. Host Apps \u00b6 A host app is a phenix app that 1) does not get applied to all nodes in the experiment topology, and/or 2) requires a unique configuration for each node. For example, a phenix app that configures a VPN between two nodes in an experiment using WireGuard would need to be a host app because 1) only two nodes will be modified, and 2) each of the two nodes will require different configurations (e.g., one will be a WireGuard client and the other a WireGuard server). Each configured host app will contain a list of topology nodes to apply the app to, along with custom metadata for the app specific to the topology node. Example \u00b6 The following is an example of a configuration for a scenario named foobar , which can only be applied to an accompanying topology named foobar (while these names are the same in this example, the topology and scenario names do not have to match). Included in this scenario is an experiment app named miniccc-injector and three host apps: startup , protonuke and wireguard . Each entry in the list of app hosts includes custom app metadata and the hostname of the topology node to apply the metadata to. apiVersion: phenix.sandia.gov/v1 kind: Scenario metadata: name: foobar annotations: topology: foobar spec: apps: experiment: - name: miniccc-injector metadata: # files to inject into each node in experiment, based on OS type linux: src: /phenix/injects/miniccc dst: /usr/local/bin/miniccc windows: src: /phenix/injects/miniccc.exe dst: phenix/miniccc.exe host: - name: startup hosts: - hostname: host-00 # hostname of topology node to apply it to metadata: domain_controller: domain: example.com ip: 10.0.0.1 username: admin password: SuperSecretPassword - name: protonuke hosts: - hostname: host-01 # hostname of topology node to apply it to metadata: # protonuke app metadata for this topology node args: -logfile /var/log/protonuke.log -level debug -http -https -smtp -ssh 192.168.100.100 - name: wireguard hosts: - hostname: AD1 # hostname of topology node to apply it to metadata: # wireguard app metadata for this topology node infrastructure: private_key: GLlxWJom8cQViGHojqOUShWIZG7IsSX8 address: 10.255.255.1/24 listen_port: 51820 peers: public_key: +joyya2F9g72qbKBtPDn00mIevG1j1OqeN76ylFLsiE= allowed_ips: 10.255.255.10/32 Note The above example includes a host app named startup , which is a phenix default app. Meaning, it is possible to configure default phenix apps in a scenario configuration, not just user apps. Experiment \u00b6 Experiment configurations represent the combination of topologies and scenarios to form an experiment (though experiments do not require a scenario). Typically experiment configurations are created automatically , but it is possible to create them manually using a configuration file similar to the one shown below. In this case, an experiment named foobar would be created based on an existing topology named foobar and an existing scenario named foobar (note that none of the names have to match). apiVersion: phenix.sandia.gov/v1 kind: Experiment metadata: name: foobar annotations: topology: foobar # this is required scenario: foobar # this is optional Once created, either manually or automatically, the experiment configuration will be expanded to have the topology and scenario configurations embedded in it, as well as additional details like cluster host schedules for VMs, VLAN ranges, etc. The advantage of embedding the topology and scenario into the experiment is that they can be modified in the experiment without modifying the originals. Image \u00b6 The Image configuration is used to generate VM disk images using a custom version of vmdb2 . Representing a disk image in a configuration like this allows for the same disk image to easily be built in different clusters without having to actually move large disk image files. Typically image configurations are created automatically , but users can also create them manually using a configuration file similar to the one shown below. apiVersion: phenix.sandia.gov/v1 kind: Image metadata: name: foobar spec: format: qcow2 mirror: http://us.archive.ubuntu.com/ubuntu/ packages: - initramfs-tools - net-tools - isc-dhcp-client - openssh-server - init - iputils-ping - vim - less - netbase - curl - ifupdown - dbus - linux-image-generic - linux-headers-generic release: bionic size: 5G variant: minbase scripts: POSTBUILD_APT_CLEANUP: | apt clean || apt-get clean || echo \"unable to clean apt cache\" POSTBUILD_NO_ROOT_PASSWD: | sed -i 's/nullok_secure/nullok/' /etc/pam.d/common-auth sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config sed -i 's/#PermitEmptyPasswords no/PermitEmptyPasswords yes/' /etc/ssh/sshd_config sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config sed -i 's/PermitEmptyPasswords no/PermitEmptyPasswords yes/' /etc/ssh/sshd_config passwd -d root User \u00b6 The User configuration tracks phenix UI user settings (e.g., username, password, and RBAC permissions). Typically user configurations are created automatically when a UI admin creates a new user via the UI, but they can also be created manually using a configuration file similar to the one shown below. apiVersion: phenix.sandia.gov/v1 kind: User metadata: name: admin@foo.com spec: username: admin@foo.com first_name: Admin last_name: Istrator password: **************** rbac: roleName: Global Admin policies: - resourceNames: - '*' resources: - '*' - '*/*' verbs: - '*' - resourceNames: - admin@foo.com resources: - users verbs: - get Role \u00b6 The Role configuration is used to represent a named set of RBAC permissions that represent a user's role in the UI. When a new user is created, the role that user should have is specified, and using that role name the appropriate RBAC permissions are copied from the role configuration into the user configuration. There are six (6) default role configurations that get created automatically, and are described here . An example role configuration is shown below for completeness. apiVersion: phenix.sandia.gov/v1 kind: Role metadata: name: global-admin spec: roleName: Global Admin policies: - resourceNames: - '*' resources: - '*' - '*/*' verbs: - '*'","title":"Configuration Files"},{"location":"configuration/#configuration-files","text":"phenix currently supports six (6) different configuration file types: Topology Scenario Experiment Image User Role Typically, users will create Topology and Scenario configuration files by hand, while the rest will be generated by phenix using available commands. However, it is possible to create all configuration file types by hand if necessary. Configuration files are versioned using a header section based heavily on what Kubernetes does. Each configuration file will have a header section that looks like the following: apiVersion: phenix.sandia.gov/v1 kind: Topology metadata: name: foobar spec: ... In the example above, the kind field represents the type of configuration file (e.g., Topology, Scenario, Image). The apiVersion field represents the version the spec section conforms to (currently there is only v1 for all configuration types), and the spec section will contain the actual details for the configuration type based on the configuration schema. Note that, at least in the header section, keys are camel-case and begin with a lowercase letter, while values are camel-cased but begin with a capital letter. Note Throughout the documentation, we mention creating configurations manually . When we say this, we mean passing a YAML or JSON configuration file of any type to the phenix config create command.","title":"Configuration Files"},{"location":"configuration/#topology","text":"The Topology configuration is one of the core configuration types for phenix , as it describes a network topology to be deployed in minimega that can be used by one or more experiments to be executed. A topology is comprised of one or more nodes (which is a VM or container), each including system descriptions and configurations, as well as any networking settings required to connect all of the nodes in a topology together. This configuration becomes the basis for most of the minimega commands later created in the relevant minimega startup script.","title":"Topology"},{"location":"configuration/#default-settings","text":"If left unmodified or unset, the following are the default settings for each node: - memory will be set to 512MB - snapshot will be set to true - no network settings will be included","title":"Default Settings"},{"location":"configuration/#required-values","text":"Each topology must have a unique name, which should be lowercase and not include spaces. In addition, each node in the topology must: have a specified type (available types are defined in the schema have a unique hostname have an OS type of linux or windows have a disk image assigned","title":"Required Values"},{"location":"configuration/#optional-values","text":"Optional values for a node in the topology configuration can include: static network configurations specific memory values (e.g., 1-16GB) specific VCPUs values (e.g., 1-4) additional disk storage file injections labels (typically used by phenix apps) routing ruleset(s)","title":"Optional Values"},{"location":"configuration/#example","text":"A contrived, four node example -- three VMs and a router -- is given below, and is driven by the topology schema described here . apiVersion: phenix.sandia.gov/v1 kind: Topology metadata: name: foobar spec: nodes: - type: VirtualMachine general: hostname: host-00 snapshot: true hardware: os_type: linux drives: - image: ubuntu.qc2 injections: - src: foo/bar/sucka.fish dst: /data/sucka.fish - src: /foo/bar/sucka/fish.sh dst: /data/fish.sh network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.1 mask: 24 gateway: 192.168.10.254 proto: static type: ethernet - name: IF1 vlan: MGMT address: 172.16.10.1 mask: 16 proto: static type: ethernet - type: VirtualMachine general: hostname: host-01 snapshot: true hardware: os_type: linux drives: - image: ubuntu.qc2 network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.2 mask: 24 gateway: 192.168.10.254 proto: static type: ethernet - name: IF1 vlan: MGMT address: 172.16.10.2 mask: 16 proto: static type: ethernet - name: S0 vlan: EXT address: 10.0.0.1 mask: 24 proto: static type: serial udp_port: 8989 baud_rate: 9600 device: /dev/ttyS0 - type: VirtualMachine general: hostname: AD1 snapshot: true hardware: os_type: windows drives: - image: win-svr-2k8.qc2 network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.250 mask: 24 gateway: 192.168.10.254 proto: static type: ethernet - name: IF1 vlan: MGMT address: 172.16.10.3 mask: 16 proto: static type: ethernet - type: Router labels: ntp-server: \"true\" general: hostname: router-00 snapshot: true hardware: os_type: linux drives: - image: vyatta.qc2 network: interfaces: - name: IF0 vlan: EXP-1 address: 192.168.10.254 mask: 24 proto: static type: ethernet ruleset_in: test - name: IF1 vlan: MGMT address: 172.16.10.254 mask: 16 proto: static type: ethernet rulesets: - name: test default: drop rules: - id: 10 action: accept protocol: all source: address: 1.1.1.1 port: 53","title":"Example"},{"location":"configuration/#scenario","text":"The Scenario configuration is used to define and configure one or more phenix apps ( default or user ) for use on a topology. In this sense, a topology can have one or more scenarios associated with it, but a scenario can only be associated with a single topology. There are two categories of phenix apps that can be configured in a scenario: 1) experiment, and 2) host. A scenario can contain zero or more experiment and/or host apps.","title":"Scenario"},{"location":"configuration/#experiment-apps","text":"An experiment app is a phenix app that can be applied to experiment topology using a single configuration. For example, a phenix app that adds a minimega tap to all hosts in the cluster or one that injects the same file into every node in the experiment topology would be good candidates for an experiment app.","title":"Experiment Apps"},{"location":"configuration/#host-apps","text":"A host app is a phenix app that 1) does not get applied to all nodes in the experiment topology, and/or 2) requires a unique configuration for each node. For example, a phenix app that configures a VPN between two nodes in an experiment using WireGuard would need to be a host app because 1) only two nodes will be modified, and 2) each of the two nodes will require different configurations (e.g., one will be a WireGuard client and the other a WireGuard server). Each configured host app will contain a list of topology nodes to apply the app to, along with custom metadata for the app specific to the topology node.","title":"Host Apps"},{"location":"configuration/#example_1","text":"The following is an example of a configuration for a scenario named foobar , which can only be applied to an accompanying topology named foobar (while these names are the same in this example, the topology and scenario names do not have to match). Included in this scenario is an experiment app named miniccc-injector and three host apps: startup , protonuke and wireguard . Each entry in the list of app hosts includes custom app metadata and the hostname of the topology node to apply the metadata to. apiVersion: phenix.sandia.gov/v1 kind: Scenario metadata: name: foobar annotations: topology: foobar spec: apps: experiment: - name: miniccc-injector metadata: # files to inject into each node in experiment, based on OS type linux: src: /phenix/injects/miniccc dst: /usr/local/bin/miniccc windows: src: /phenix/injects/miniccc.exe dst: phenix/miniccc.exe host: - name: startup hosts: - hostname: host-00 # hostname of topology node to apply it to metadata: domain_controller: domain: example.com ip: 10.0.0.1 username: admin password: SuperSecretPassword - name: protonuke hosts: - hostname: host-01 # hostname of topology node to apply it to metadata: # protonuke app metadata for this topology node args: -logfile /var/log/protonuke.log -level debug -http -https -smtp -ssh 192.168.100.100 - name: wireguard hosts: - hostname: AD1 # hostname of topology node to apply it to metadata: # wireguard app metadata for this topology node infrastructure: private_key: GLlxWJom8cQViGHojqOUShWIZG7IsSX8 address: 10.255.255.1/24 listen_port: 51820 peers: public_key: +joyya2F9g72qbKBtPDn00mIevG1j1OqeN76ylFLsiE= allowed_ips: 10.255.255.10/32 Note The above example includes a host app named startup , which is a phenix default app. Meaning, it is possible to configure default phenix apps in a scenario configuration, not just user apps.","title":"Example"},{"location":"configuration/#experiment","text":"Experiment configurations represent the combination of topologies and scenarios to form an experiment (though experiments do not require a scenario). Typically experiment configurations are created automatically , but it is possible to create them manually using a configuration file similar to the one shown below. In this case, an experiment named foobar would be created based on an existing topology named foobar and an existing scenario named foobar (note that none of the names have to match). apiVersion: phenix.sandia.gov/v1 kind: Experiment metadata: name: foobar annotations: topology: foobar # this is required scenario: foobar # this is optional Once created, either manually or automatically, the experiment configuration will be expanded to have the topology and scenario configurations embedded in it, as well as additional details like cluster host schedules for VMs, VLAN ranges, etc. The advantage of embedding the topology and scenario into the experiment is that they can be modified in the experiment without modifying the originals.","title":"Experiment"},{"location":"configuration/#image","text":"The Image configuration is used to generate VM disk images using a custom version of vmdb2 . Representing a disk image in a configuration like this allows for the same disk image to easily be built in different clusters without having to actually move large disk image files. Typically image configurations are created automatically , but users can also create them manually using a configuration file similar to the one shown below. apiVersion: phenix.sandia.gov/v1 kind: Image metadata: name: foobar spec: format: qcow2 mirror: http://us.archive.ubuntu.com/ubuntu/ packages: - initramfs-tools - net-tools - isc-dhcp-client - openssh-server - init - iputils-ping - vim - less - netbase - curl - ifupdown - dbus - linux-image-generic - linux-headers-generic release: bionic size: 5G variant: minbase scripts: POSTBUILD_APT_CLEANUP: | apt clean || apt-get clean || echo \"unable to clean apt cache\" POSTBUILD_NO_ROOT_PASSWD: | sed -i 's/nullok_secure/nullok/' /etc/pam.d/common-auth sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config sed -i 's/#PermitEmptyPasswords no/PermitEmptyPasswords yes/' /etc/ssh/sshd_config sed -i 's/PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config sed -i 's/PermitEmptyPasswords no/PermitEmptyPasswords yes/' /etc/ssh/sshd_config passwd -d root","title":"Image"},{"location":"configuration/#user","text":"The User configuration tracks phenix UI user settings (e.g., username, password, and RBAC permissions). Typically user configurations are created automatically when a UI admin creates a new user via the UI, but they can also be created manually using a configuration file similar to the one shown below. apiVersion: phenix.sandia.gov/v1 kind: User metadata: name: admin@foo.com spec: username: admin@foo.com first_name: Admin last_name: Istrator password: **************** rbac: roleName: Global Admin policies: - resourceNames: - '*' resources: - '*' - '*/*' verbs: - '*' - resourceNames: - admin@foo.com resources: - users verbs: - get","title":"User"},{"location":"configuration/#role","text":"The Role configuration is used to represent a named set of RBAC permissions that represent a user's role in the UI. When a new user is created, the role that user should have is specified, and using that role name the appropriate RBAC permissions are copied from the role configuration into the user configuration. There are six (6) default role configurations that get created automatically, and are described here . An example role configuration is shown below for completeness. apiVersion: phenix.sandia.gov/v1 kind: Role metadata: name: global-admin spec: roleName: Global Admin policies: - resourceNames: - '*' resources: - '*' - '*/*' verbs: - '*'","title":"Role"},{"location":"experiments/","text":"Experiments \u00b6 Listing Experiments \u00b6 From the Web-UI \u00b6 Click on the Experiments tab. This will display all available experiments that the user has access to view or edit. From the Command Line Binary \u00b6 This will display a list of all available experiments: it is run as a root user. $> phenix exp list Starting / Stopping Experiments \u00b6 From the Web-UI \u00b6 Clicking the stopped button will start the experiment; similarly the started button will stop the experiment. A progress bar is used to update the progress of starting an experiment. During the update to the experiment -- starting or stopping -- it will not be accessible or available to delete. From the Command Line Binary \u00b6 $> phenix exp start <experiment name> Or ... $> phenix exp stop <experiment name> Or ... $> phenix exp restart <experiment name> Optionally, you can use the --dry-run flag to do everything expect call out to minimega. The phenix exp --help command will output: Experiment management Usage: phenix experiment [flags] phenix experiment [command] Aliases: experiment, exp Available Commands: apps List of available apps to assign an experiment create Create an experiment delete Delete an experiment list Display a table of available experiments restart Start an experiment schedule Schedule an experiment schedulers List of available schedulers to assign an experiment start Start an experiment stop Stop an experiment Flags: -h, --help help for experiment Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/root/.phenix.err\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///root/.phenix.bdb\") Use \"phenix experiment [command] --help\" for more information about a command. Create a New Experiment \u00b6 From the Web-UI \u00b6 Click the + button to the right of the filter field. Enter Experiment Name and Experiment Topology , the remaining selection are optional. In this example, bennu is an example topology and is not included by default. You will need to create your own topology(ies). From the Command Line Binary \u00b6 Three options are available from the command line. The only requirements are for an experiment and topology name; scenario and base directory are optional. $> phenix experiment create <experiment name> -t <topology name> $> phenix experiment create <experiment name> -t <topology name> -s <scenario name> $> phenix experiment create <experiment name> -t <topology name> -s <scenario name> -d </path/to/dir/>` The phenix exp create --help command will output: Create an experiment Used to create an experiment from an existing configuration; can be a topology, or topology and scenario. (Optional are the arguments for scenario or base directory.) Usage: phenix experiment create <experiment name> [flags] Examples: phenix experiment create <experiment name> -t <topology name> phenix experiment create <experiment name> -t <topology name> -s <scenario name> phenix experiment create <experiment name> -t <topology name> -s <scenario name> -d </path/to/dir/> Flags: -d, --base-dir string Base directory to use for experiment (optional) -h, --help help for create -s, --scenario string Name of an existing scenario to use (optional) -t, --topology string Name of an existing topology to use Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/root/.phenix.err\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///root/.phenix.bdb\") Scheduling an Experiment \u00b6 From Web-UI \u00b6 The experiment must be stopped; click on the experiment name to enter the Stopped Experiment component. Click on the hamburger menu to the right of the filter field and start button to select a desired schedule. From the Command Line Binary \u00b6 The list of available schedules can be found by running the folowing command. $> phenix exp schedulers Then apply the desired schedule with the following command. $> phenix experiment schedule <experiment name> <algorithm>","title":"Experiments"},{"location":"experiments/#experiments","text":"","title":"Experiments"},{"location":"experiments/#listing-experiments","text":"","title":"Listing Experiments"},{"location":"experiments/#from-the-web-ui","text":"Click on the Experiments tab. This will display all available experiments that the user has access to view or edit.","title":"From the Web-UI"},{"location":"experiments/#from-the-command-line-binary","text":"This will display a list of all available experiments: it is run as a root user. $> phenix exp list","title":"From the Command Line Binary"},{"location":"experiments/#starting-stopping-experiments","text":"","title":"Starting / Stopping Experiments"},{"location":"experiments/#from-the-web-ui_1","text":"Clicking the stopped button will start the experiment; similarly the started button will stop the experiment. A progress bar is used to update the progress of starting an experiment. During the update to the experiment -- starting or stopping -- it will not be accessible or available to delete.","title":"From the Web-UI"},{"location":"experiments/#from-the-command-line-binary_1","text":"$> phenix exp start <experiment name> Or ... $> phenix exp stop <experiment name> Or ... $> phenix exp restart <experiment name> Optionally, you can use the --dry-run flag to do everything expect call out to minimega. The phenix exp --help command will output: Experiment management Usage: phenix experiment [flags] phenix experiment [command] Aliases: experiment, exp Available Commands: apps List of available apps to assign an experiment create Create an experiment delete Delete an experiment list Display a table of available experiments restart Start an experiment schedule Schedule an experiment schedulers List of available schedulers to assign an experiment start Start an experiment stop Stop an experiment Flags: -h, --help help for experiment Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/root/.phenix.err\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///root/.phenix.bdb\") Use \"phenix experiment [command] --help\" for more information about a command.","title":"From the Command Line Binary"},{"location":"experiments/#create-a-new-experiment","text":"","title":"Create a New Experiment"},{"location":"experiments/#from-the-web-ui_2","text":"Click the + button to the right of the filter field. Enter Experiment Name and Experiment Topology , the remaining selection are optional. In this example, bennu is an example topology and is not included by default. You will need to create your own topology(ies).","title":"From the Web-UI"},{"location":"experiments/#from-the-command-line-binary_2","text":"Three options are available from the command line. The only requirements are for an experiment and topology name; scenario and base directory are optional. $> phenix experiment create <experiment name> -t <topology name> $> phenix experiment create <experiment name> -t <topology name> -s <scenario name> $> phenix experiment create <experiment name> -t <topology name> -s <scenario name> -d </path/to/dir/>` The phenix exp create --help command will output: Create an experiment Used to create an experiment from an existing configuration; can be a topology, or topology and scenario. (Optional are the arguments for scenario or base directory.) Usage: phenix experiment create <experiment name> [flags] Examples: phenix experiment create <experiment name> -t <topology name> phenix experiment create <experiment name> -t <topology name> -s <scenario name> phenix experiment create <experiment name> -t <topology name> -s <scenario name> -d </path/to/dir/> Flags: -d, --base-dir string Base directory to use for experiment (optional) -h, --help help for create -s, --scenario string Name of an existing scenario to use (optional) -t, --topology string Name of an existing topology to use Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/root/.phenix.err\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///root/.phenix.bdb\")","title":"From the Command Line Binary"},{"location":"experiments/#scheduling-an-experiment","text":"","title":"Scheduling an Experiment"},{"location":"experiments/#from-web-ui","text":"The experiment must be stopped; click on the experiment name to enter the Stopped Experiment component. Click on the hamburger menu to the right of the filter field and start button to select a desired schedule.","title":"From Web-UI"},{"location":"experiments/#from-the-command-line-binary_3","text":"The list of available schedules can be found by running the folowing command. $> phenix exp schedulers Then apply the desired schedule with the following command. $> phenix experiment schedule <experiment name> <algorithm>","title":"From the Command Line Binary"},{"location":"image/","text":"Virtual Disk Images Management \u00b6 This is only available from the command line binary at this time. Listing disk images \u00b6 $> phenix image list Creating a disk image \u00b6 The vmdb2 utility is required -- in path -- to create the disk images. $> phenix image create <image name> The phenix image create --help will output: Create a disk image configuration Used to create a virtual disk image configuration from which to build an image Usage: phenix image create <image name> [flags] Examples: phenix image create <image name> phenix image create --size 2G --variant mingui --release xenial --format qcow2 --compress --overlays foobar --packages foo --scripts bar <image name> Flags: -c, --compress Compress image after creation (does not apply to raw image) -d, --debootstrap-append string Additional arguments to debootstrap \"(default: --components=main,restricted,universe,multiverse)\" -f, --format string Format of disk image (default \"raw\") -h, --help help for create -m, --mirror string Debootstrap mirror (must match release) (default \"http://us.archive.ubuntu.com/ubuntu/\") -O, --overlays string List of overlay names (include full path; separated by comma) -P, --packages string List of packages to include in addition to those provided by variant (separated by comma) -R, --ramdisk Create a kernel/initrd pair in addition to a disk image -r, --release string OS release codename (default \"bionic\") -T, --scripts string List of scripts to include in addition to the defaults (include full path; separated by comma) -s, --size string Image size to use (default \"5G\") -v, --variant string Image variant to use (default \"minbase\") Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/var/log/phenix/error.log\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\") The vmdb2 configuration file can be read by running the following command: $> phenix cfg get image/<image name> Building a disk image \u00b6 Building a disk image requires an existing configuration in the store (i.e., the create command should be run first to create a configuration); the phenix image build --help will output: Build a virtual disk image Used to build a new virtual disk using an exisitng configuration; vmdb2 must be in path. Usage: phenix image build <configuration name> [flags] Examples: phenix image build <configuration name> phenix image build --very-very-verbose --output </path/to/dir/> Flags: -c, --cache Cache rootfs as tar archive --dry-run Do everything but actually call out to vmdb2 -h, --help help for build -o, --output string Specify the output directory for the disk image to be saved to -v, --verbose Enable verbose output -w, --very-verbose Enable very verbose output -x, --very-very-verbose Enable very verbose output plus additional verbose output from debootstrap Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/var/log/phenix/error.log\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\") Miscellaneous Commands \u00b6 Append \u00b6 The disk image management tool will allow you to add packages, overlays, and scripts to exisitng configurations using the append command. Command usage is: $> phenix image append <configuration name> [flags] Flags are for the overlays, packages, and scripts that you want to append. Create From an Existing Configuration \u00b6 Run this command if you have an existing configuration that you would like to use as the base to create a new configuration from. The usage involves referencing the existing configuration, the new configuration name, and then additional packages, overlays, and scripts. $> phenix image create-from <existing configuration> <new configuration> [flags] Flags are for the overlays, packages, and scripts that you want to add to the new configuration. Delete \u00b6 $> phenix image delete <image name> An alternative could be to use the configuration management tool. $> phenix cfg delete image/<image name> Remove \u00b6 The remove command will allow you to remove any packages, overlays, and scripts from an existing image configuration. $> phenix image remove <configuration name> [flags] Flags are for the overlays, packages, and scripts that you want to remove. Update \u00b6 This update command is used to update the script on an existing image configuration. The path to a script is tracked in the code. The image configuration gets updated with the script in the path; if no changes were made no harm. If the path no longer exists, phenix will leave the configuration alone. $> phenix image update <configuration name>","title":"Virtual Disk Images Management"},{"location":"image/#virtual-disk-images-management","text":"This is only available from the command line binary at this time.","title":"Virtual Disk Images Management"},{"location":"image/#listing-disk-images","text":"$> phenix image list","title":"Listing disk images"},{"location":"image/#creating-a-disk-image","text":"The vmdb2 utility is required -- in path -- to create the disk images. $> phenix image create <image name> The phenix image create --help will output: Create a disk image configuration Used to create a virtual disk image configuration from which to build an image Usage: phenix image create <image name> [flags] Examples: phenix image create <image name> phenix image create --size 2G --variant mingui --release xenial --format qcow2 --compress --overlays foobar --packages foo --scripts bar <image name> Flags: -c, --compress Compress image after creation (does not apply to raw image) -d, --debootstrap-append string Additional arguments to debootstrap \"(default: --components=main,restricted,universe,multiverse)\" -f, --format string Format of disk image (default \"raw\") -h, --help help for create -m, --mirror string Debootstrap mirror (must match release) (default \"http://us.archive.ubuntu.com/ubuntu/\") -O, --overlays string List of overlay names (include full path; separated by comma) -P, --packages string List of packages to include in addition to those provided by variant (separated by comma) -R, --ramdisk Create a kernel/initrd pair in addition to a disk image -r, --release string OS release codename (default \"bionic\") -T, --scripts string List of scripts to include in addition to the defaults (include full path; separated by comma) -s, --size string Image size to use (default \"5G\") -v, --variant string Image variant to use (default \"minbase\") Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/var/log/phenix/error.log\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\") The vmdb2 configuration file can be read by running the following command: $> phenix cfg get image/<image name>","title":"Creating a disk image"},{"location":"image/#building-a-disk-image","text":"Building a disk image requires an existing configuration in the store (i.e., the create command should be run first to create a configuration); the phenix image build --help will output: Build a virtual disk image Used to build a new virtual disk using an exisitng configuration; vmdb2 must be in path. Usage: phenix image build <configuration name> [flags] Examples: phenix image build <configuration name> phenix image build --very-very-verbose --output </path/to/dir/> Flags: -c, --cache Cache rootfs as tar archive --dry-run Do everything but actually call out to vmdb2 -h, --help help for build -o, --output string Specify the output directory for the disk image to be saved to -v, --verbose Enable verbose output -w, --very-verbose Enable very verbose output -x, --very-very-verbose Enable very verbose output plus additional verbose output from debootstrap Global Flags: --base-dir.minimega string base minimega directory (default \"/tmp/minimega\") --base-dir.phenix string base phenix directory (default \"/phenix\") --hostname-suffixes string hostname suffixes to strip --log.error-file string log fatal errors to file (default \"/var/log/phenix/error.log\") --log.error-stderr log fatal errors to STDERR --store.endpoint string endpoint for storage service (default \"bolt:///etc/phenix/store.bdb\")","title":"Building a disk image"},{"location":"image/#miscellaneous-commands","text":"","title":"Miscellaneous Commands"},{"location":"image/#append","text":"The disk image management tool will allow you to add packages, overlays, and scripts to exisitng configurations using the append command. Command usage is: $> phenix image append <configuration name> [flags] Flags are for the overlays, packages, and scripts that you want to append.","title":"Append"},{"location":"image/#create-from-an-existing-configuration","text":"Run this command if you have an existing configuration that you would like to use as the base to create a new configuration from. The usage involves referencing the existing configuration, the new configuration name, and then additional packages, overlays, and scripts. $> phenix image create-from <existing configuration> <new configuration> [flags] Flags are for the overlays, packages, and scripts that you want to add to the new configuration.","title":"Create From an Existing Configuration"},{"location":"image/#delete","text":"$> phenix image delete <image name> An alternative could be to use the configuration management tool. $> phenix cfg delete image/<image name>","title":"Delete"},{"location":"image/#remove","text":"The remove command will allow you to remove any packages, overlays, and scripts from an existing image configuration. $> phenix image remove <configuration name> [flags] Flags are for the overlays, packages, and scripts that you want to remove.","title":"Remove"},{"location":"image/#update","text":"This update command is used to update the script on an existing image configuration. The path to a script is tracked in the code. The image configuration gets updated with the script in the path; if no changes were made no harm. If the path no longer exists, phenix will leave the configuration alone. $> phenix image update <configuration name>","title":"Update"},{"location":"schema/","text":"Configuration File Schemas \u00b6 The following schemas are all represented using the OpenAPIv3 format. Topology Schema \u00b6 The topology schema is largely comprised of nodes, described here . Topology: type: object title: Demo Topology required: - nodes properties: nodes: type: array title: Nodes items: $ref: \"#/components/schemas/Node\" Scenario Schema \u00b6 INCOMPLETE SCHEMA This schema definition is not complete. Scenario: type: object required: - apps properties: apps: type: object properties: experiment: type: array items: type: object required: - name properties: name: type: string minLength: 1 Experiment Schema \u00b6 INCOMPLETE SCHEMA This schema definition is not complete. Experiment: type: object required: - experimentName properties: experimentName: type: string minLength: 1 baseDir: type: string vlans: type: object title: VLANs properties: aliases: type: object title: Aliases additionalProperties: type: integer example: MGMT: 200 min: type: integer max: type: integer schedule: type: object title: Schedule additionalProperties: type: string example: ADServer: compute1 Image Schema \u00b6 INCOMPLETE SCHEMA This schema definition is not complete. Image: type: object title: ubuntu Image required: - release properties: release: type: string minLength: 1 User Schema \u00b6 MISSING SCHEMA This schema definition does not (yet) exist. Role Schema \u00b6 MISSING SCHEMA This schema definition does not (yet) exist. Node Schema \u00b6 The node schema contains references to the interface schema described here . Node: type: object title: Node required: - type - general - hardware properties: type: type: string title: Node Type enum: - Firewall - Printer - Router - Server - Switch - VirtualMachine default: VirtualMachine example: VirtualMachine general: type: object title: General Node Configuration required: - hostname properties: hostname: type: string title: Hostname minLength: 1 example: ADServer description: type: string title: Description example: Active Directory Server vm_type: type: string title: VM (Emulation) Type enum: - kvm - container - \"\" default: kvm example: kvm snapshot: type: boolean title: Snapshot Mode default: false example: false nullable: true do_not_boot: type: boolean title: Do Not Boot VM default: false example: false nullable: true hardware: type: object title: Node Hardware Configuration required: - os_type - drives properties: cpu: type: string title: CPU Emulation enum: - Broadwell - Haswell - core2duo - pentium3 - \"\" default: Broadwell example: Broadwell vcpus: type: integer title: VCPU Count default: 1 example: 4 memory: type: integer title: Memory default: 1024 example: 8192 os_type: type: string title: OS Type enum: - windows - linux - rhel - centos default: linux example: windows drives: type: array title: Drives items: type: object title: Drive required: - image properties: image: type: string title: Image File Name minLength: 1 example: ubuntu.qc2 interface: type: string title: Drive Interface enum: - ahci - ide - scsi - sd - mtd - floppy - pflash - virtio - \"\" default: ide example: ide cache_mode: type: string title: Drive Cache Mode enum: - none - writeback - unsafe - directsync - writethrough - \"\" default: writeback example: writeback inject_partition: type: integer title: Disk Image Partition to Inject Files Into default: 1 example: 2 nullable: true network: type: object title: Node Network Configuration required: - interfaces properties: interfaces: type: array title: Network Interfaces items: type: object title: Network Interface oneOf: - $ref: '#/components/schemas/static_iface' - $ref: '#/components/schemas/dhcp_iface' - $ref: '#/components/schemas/serial_iface' routes: type: array items: type: object title: Network Route required: - destination - next - cost properties: destination: type: string title: Routing Destination minLength: 1 example: 192.168.0.0/24 next: type: string title: Next Hop for Routing Destination minLength: 1 example: 192.168.1.254 cost: type: integer title: Routing Cost (weight) default: 1 example: 1 ospf: type: object title: OSPF Routing Configuration required: - router_id - areas properties: router_id: type: string title: Router ID minLength: 1 example: 0.0.0.1 areas: type: array title: Routing Areas items: type: object title: Routing Area required: - area_id - area_networks properties: area_id: type: integer title: Area ID example: 1 default: 1 area_networks: type: array title: Area Networks items: type: object title: Area Network required: - network properties: network: type: string title: Network minLength: 1 example: 10.1.25.0/24 rulesets: type: array title: Firewall Rulesets items: type: object title: Firewall Ruleset required: - name - default - rules properties: name: type: string title: Ruleset Name minLength: 1 example: OutToDMZ description: type: string title: Ruleset Description minLength: 1 example: From Corp to the DMZ network default: type: string title: Default Firewall Action enum: - accept - drop - reject example: drop rules: type: array title: Firewall Rules items: type: object title: Firewall Rule required: - id - action - protocol properties: id: type: integer title: Rule ID example: 10 description: type: string title: Rule Description example: Allow UDP 10.1.26.80 ==> 10.2.25.0/24:123 action: type: string title: Rule Action enum: - accept - drop - reject example: accept protocol: type: string title: Network Protocol enum: - tcp - udp - icmp - esp - ah - all default: tcp example: tcp source: type: object title: Source Address required: - address properties: address: type: string title: IP Address minLength: 1 example: 10.1.24.60 port: type: integer title: Port Number example: 3389 destination: type: object title: Destination Address required: - address properties: address: type: string title: IP Address minLength: 1 example: 10.1.24.60 port: type: integer title: Port Number example: 3389 injections: type: array title: Node File Injections items: type: object title: Node File Injection required: - src - dst properties: src: type: string title: Location of Source File to Inject minLength: 1 example: foo.xml dst: type: string title: Destination Location to Inject File To minLength: 1 example: /etc/phenix/foo.xml description: type: string title: Description of file being injected example: phenix config file permissions: type: string title: Injected file permissions (UNIX style) example: 0664 Interface Schema \u00b6 iface: type: object required: - name - vlan properties: name: type: string title: Name minLength: 1 example: eth0 vlan: type: string title: VLAN minLength: 1 example: EXP-1 autostart: type: boolean title: Auto Start Interface default: true mac: type: string title: Interface MAC Address example: 00:11:22:33:44:55:66 pattern: '^([0-9a-fA-F]{2}[:-]){5}([0-9a-fA-F]){2}$' mtu: type: integer title: Interface MTU default: 1500 example: 1500 bridge: type: string title: OpenVSwitch Bridge default: phenix iface_address: type: object required: - address - mask properties: address: type: string format: ipv4 title: IP Address minLength: 7 example: 192.168.1.100 mask: type: integer title: IP Address Netmask minimum: 0 maximum: 32 default: 24 example: 24 gateway: type: string format: ipv4 title: Default Gateway minLength: 7 example: 192.168.1.1 iface_rulesets: type: object properties: ruleset_out: type: string title: Outbound Ruleset example: OutToInet pattern: '^[\\w-]+$' ruleset_in: type: string title: Inbound Ruleset example: InFromInet pattern: '^[\\w-]+$' static_iface: allOf: - $ref: '#/components/schemas/iface' - $ref: '#/components/schemas/iface_address' - $ref: '#/components/schemas/iface_rulesets' required: - type - proto properties: type: type: string title: Interface Type enum: - ethernet default: ethernet example: ethernet proto: type: string title: Interface Protocol enum: - static - ospf default: static example: static dhcp_iface: allOf: - $ref: '#/components/schemas/iface' - $ref: '#/components/schemas/iface_rulesets' required: - type - proto properties: type: type: string title: Interface Type enum: - ethernet default: ethernet example: ethernet proto: type: string title: Interface Protocol enum: - dhcp default: dhcp example: dhcp serial_iface: allOf: - $ref: '#/components/schemas/iface' - $ref: '#/components/schemas/iface_address' - $ref: '#/components/schemas/iface_rulesets' required: - type - proto - udp_port - baud_rate - device properties: type: type: string title: Interface Type enum: - serial default: serial example: serial proto: type: string title: Interface Protocol enum: - static default: static example: static udp_port: type: integer title: UDP Port minimum: 0 maximum: 65535 default: 8989 example: 8989 baud_rate: type: integer title: Serial Baud Rate enum: - 110 - 300 - 600 - 1200 - 2400 - 4800 - 9600 - 14400 - 19200 - 38400 - 57600 - 115200 - 128000 - 256000 default: 9600 example: 9600 device: type: string title: Serial Device minLength: 1 default: /dev/ttyS0 example: /dev/ttyS0 pattern: '^[\\w\\/]+\\w+$'","title":"Configuration File Schemas"},{"location":"schema/#configuration-file-schemas","text":"The following schemas are all represented using the OpenAPIv3 format.","title":"Configuration File Schemas"},{"location":"schema/#topology-schema","text":"The topology schema is largely comprised of nodes, described here . Topology: type: object title: Demo Topology required: - nodes properties: nodes: type: array title: Nodes items: $ref: \"#/components/schemas/Node\"","title":"Topology Schema"},{"location":"schema/#scenario-schema","text":"INCOMPLETE SCHEMA This schema definition is not complete. Scenario: type: object required: - apps properties: apps: type: object properties: experiment: type: array items: type: object required: - name properties: name: type: string minLength: 1","title":"Scenario Schema"},{"location":"schema/#experiment-schema","text":"INCOMPLETE SCHEMA This schema definition is not complete. Experiment: type: object required: - experimentName properties: experimentName: type: string minLength: 1 baseDir: type: string vlans: type: object title: VLANs properties: aliases: type: object title: Aliases additionalProperties: type: integer example: MGMT: 200 min: type: integer max: type: integer schedule: type: object title: Schedule additionalProperties: type: string example: ADServer: compute1","title":"Experiment Schema"},{"location":"schema/#image-schema","text":"INCOMPLETE SCHEMA This schema definition is not complete. Image: type: object title: ubuntu Image required: - release properties: release: type: string minLength: 1","title":"Image Schema"},{"location":"schema/#user-schema","text":"MISSING SCHEMA This schema definition does not (yet) exist.","title":"User Schema"},{"location":"schema/#role-schema","text":"MISSING SCHEMA This schema definition does not (yet) exist.","title":"Role Schema"},{"location":"schema/#node-schema","text":"The node schema contains references to the interface schema described here . Node: type: object title: Node required: - type - general - hardware properties: type: type: string title: Node Type enum: - Firewall - Printer - Router - Server - Switch - VirtualMachine default: VirtualMachine example: VirtualMachine general: type: object title: General Node Configuration required: - hostname properties: hostname: type: string title: Hostname minLength: 1 example: ADServer description: type: string title: Description example: Active Directory Server vm_type: type: string title: VM (Emulation) Type enum: - kvm - container - \"\" default: kvm example: kvm snapshot: type: boolean title: Snapshot Mode default: false example: false nullable: true do_not_boot: type: boolean title: Do Not Boot VM default: false example: false nullable: true hardware: type: object title: Node Hardware Configuration required: - os_type - drives properties: cpu: type: string title: CPU Emulation enum: - Broadwell - Haswell - core2duo - pentium3 - \"\" default: Broadwell example: Broadwell vcpus: type: integer title: VCPU Count default: 1 example: 4 memory: type: integer title: Memory default: 1024 example: 8192 os_type: type: string title: OS Type enum: - windows - linux - rhel - centos default: linux example: windows drives: type: array title: Drives items: type: object title: Drive required: - image properties: image: type: string title: Image File Name minLength: 1 example: ubuntu.qc2 interface: type: string title: Drive Interface enum: - ahci - ide - scsi - sd - mtd - floppy - pflash - virtio - \"\" default: ide example: ide cache_mode: type: string title: Drive Cache Mode enum: - none - writeback - unsafe - directsync - writethrough - \"\" default: writeback example: writeback inject_partition: type: integer title: Disk Image Partition to Inject Files Into default: 1 example: 2 nullable: true network: type: object title: Node Network Configuration required: - interfaces properties: interfaces: type: array title: Network Interfaces items: type: object title: Network Interface oneOf: - $ref: '#/components/schemas/static_iface' - $ref: '#/components/schemas/dhcp_iface' - $ref: '#/components/schemas/serial_iface' routes: type: array items: type: object title: Network Route required: - destination - next - cost properties: destination: type: string title: Routing Destination minLength: 1 example: 192.168.0.0/24 next: type: string title: Next Hop for Routing Destination minLength: 1 example: 192.168.1.254 cost: type: integer title: Routing Cost (weight) default: 1 example: 1 ospf: type: object title: OSPF Routing Configuration required: - router_id - areas properties: router_id: type: string title: Router ID minLength: 1 example: 0.0.0.1 areas: type: array title: Routing Areas items: type: object title: Routing Area required: - area_id - area_networks properties: area_id: type: integer title: Area ID example: 1 default: 1 area_networks: type: array title: Area Networks items: type: object title: Area Network required: - network properties: network: type: string title: Network minLength: 1 example: 10.1.25.0/24 rulesets: type: array title: Firewall Rulesets items: type: object title: Firewall Ruleset required: - name - default - rules properties: name: type: string title: Ruleset Name minLength: 1 example: OutToDMZ description: type: string title: Ruleset Description minLength: 1 example: From Corp to the DMZ network default: type: string title: Default Firewall Action enum: - accept - drop - reject example: drop rules: type: array title: Firewall Rules items: type: object title: Firewall Rule required: - id - action - protocol properties: id: type: integer title: Rule ID example: 10 description: type: string title: Rule Description example: Allow UDP 10.1.26.80 ==> 10.2.25.0/24:123 action: type: string title: Rule Action enum: - accept - drop - reject example: accept protocol: type: string title: Network Protocol enum: - tcp - udp - icmp - esp - ah - all default: tcp example: tcp source: type: object title: Source Address required: - address properties: address: type: string title: IP Address minLength: 1 example: 10.1.24.60 port: type: integer title: Port Number example: 3389 destination: type: object title: Destination Address required: - address properties: address: type: string title: IP Address minLength: 1 example: 10.1.24.60 port: type: integer title: Port Number example: 3389 injections: type: array title: Node File Injections items: type: object title: Node File Injection required: - src - dst properties: src: type: string title: Location of Source File to Inject minLength: 1 example: foo.xml dst: type: string title: Destination Location to Inject File To minLength: 1 example: /etc/phenix/foo.xml description: type: string title: Description of file being injected example: phenix config file permissions: type: string title: Injected file permissions (UNIX style) example: 0664","title":"Node Schema"},{"location":"schema/#interface-schema","text":"iface: type: object required: - name - vlan properties: name: type: string title: Name minLength: 1 example: eth0 vlan: type: string title: VLAN minLength: 1 example: EXP-1 autostart: type: boolean title: Auto Start Interface default: true mac: type: string title: Interface MAC Address example: 00:11:22:33:44:55:66 pattern: '^([0-9a-fA-F]{2}[:-]){5}([0-9a-fA-F]){2}$' mtu: type: integer title: Interface MTU default: 1500 example: 1500 bridge: type: string title: OpenVSwitch Bridge default: phenix iface_address: type: object required: - address - mask properties: address: type: string format: ipv4 title: IP Address minLength: 7 example: 192.168.1.100 mask: type: integer title: IP Address Netmask minimum: 0 maximum: 32 default: 24 example: 24 gateway: type: string format: ipv4 title: Default Gateway minLength: 7 example: 192.168.1.1 iface_rulesets: type: object properties: ruleset_out: type: string title: Outbound Ruleset example: OutToInet pattern: '^[\\w-]+$' ruleset_in: type: string title: Inbound Ruleset example: InFromInet pattern: '^[\\w-]+$' static_iface: allOf: - $ref: '#/components/schemas/iface' - $ref: '#/components/schemas/iface_address' - $ref: '#/components/schemas/iface_rulesets' required: - type - proto properties: type: type: string title: Interface Type enum: - ethernet default: ethernet example: ethernet proto: type: string title: Interface Protocol enum: - static - ospf default: static example: static dhcp_iface: allOf: - $ref: '#/components/schemas/iface' - $ref: '#/components/schemas/iface_rulesets' required: - type - proto properties: type: type: string title: Interface Type enum: - ethernet default: ethernet example: ethernet proto: type: string title: Interface Protocol enum: - dhcp default: dhcp example: dhcp serial_iface: allOf: - $ref: '#/components/schemas/iface' - $ref: '#/components/schemas/iface_address' - $ref: '#/components/schemas/iface_rulesets' required: - type - proto - udp_port - baud_rate - device properties: type: type: string title: Interface Type enum: - serial default: serial example: serial proto: type: string title: Interface Protocol enum: - static default: static example: static udp_port: type: integer title: UDP Port minimum: 0 maximum: 65535 default: 8989 example: 8989 baud_rate: type: integer title: Serial Baud Rate enum: - 110 - 300 - 600 - 1200 - 2400 - 4800 - 9600 - 14400 - 19200 - 38400 - 57600 - 115200 - 128000 - 256000 default: 9600 example: 9600 device: type: string title: Serial Device minLength: 1 default: /dev/ttyS0 example: /dev/ttyS0 pattern: '^[\\w\\/]+\\w+$'","title":"Interface Schema"},{"location":"user-administration/","text":"User Administration in ph\u0113nix \u00b6 Create a new user \u00b6 There are two primary ways to create new users. Choose the Create Account link off the login page and complete all fields one the Create a New Account dialogue. This will initiate a message to an administrator's account who can then activate the account, setting the role(s) and resource name(s). From the Users tab, click the + button to create a new user. Here the administrator will add the role(s) and resource name(s) . Login \u00b6 The login page is self-descriptive. Using the Remember me checkbox will set a token to local storage so that you can remove the requirement to enter a Username and Password each time the page or site is reloaded. If an administrator starts the UI server with the following command, authentication is enabled: $> phenix ui -k <some_string> Without the -k (or --jwt-signing-key ), authentication is disabled. User Administration \u00b6 Updating Users \u00b6 An administrator is able to click on the username on the table in the Users tab to update a user. They can update First Name or Last Name , Role , Experiment Names , and Resource Name(s) . Roles \u00b6 Global Admin is the administrator level account and has access to all capabilities, to include user management. Global Admins also have access to all resources. The following table provides a high-level overview of all the available roles and their access rights. Role Limits List Get Create Update Patch Delete Global Admin Can see and control absolutely anything/everything. E V U E V U E V U E V U E V U E V U Global Viewer Can see absolutely anything/everything, but cannot make any changes. E V U E V U Experiment Admin Can see and control anything/everything for assigned experiments, including VMs, but cannot create new experiments. E V E V V E V V V Experiment User Can see assigned experiments, and can control VMs within assigned experiments, but cannot modify experiments themselves. E V E V V Experiment Viewer Can see assigned experiments and VMs within assigned experiments, but cannot modify or control experiments or VMs. E V E V VM Viewer Can only see VM screenshots and access VM VNC, nothing else. V Key: E - experiment resource, V - VM resource, U - user resource Resources \u00b6 Resource: experiments \u00b6 Verb list Desc get a list of all experiments Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped no Verb get Desc get a specific experiment Exp. Scoped yes Res. Scoped no Verb create Desc create a new experiment Exp. Scoped no Res. Scoped no Verb delete Desc delete a specific experiment Exp. Scoped yes Res. Scoped no Resource: experiments/start \u00b6 Verb update Desc start an experiment Exp. Scoped yes Res. Scoped no Resource: experiments/stop \u00b6 Verb update Desc stop an experiment Exp. Scoped yes Res. Scoped no Resource: experiments/schedule \u00b6 Verb get Desc get current schedule for an experiment Exp. Scoped yes Res. Scoped no Verb create Desc schedule an experiment using schedule algorithm Exp. Scoped yes Res. Scoped no Resource: experiments/captures \u00b6 Verb list Desc get list of packet captures for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped yes (list is filtered to only include VMs in scope) Resource: experiments/files \u00b6 Verb list Desc get list of files for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped no Verb get Desc get specific experiment file Exp. Scoped yes Res. Scoped no Resource: vms \u00b6 Verb list Desc get list of VMs for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped yes (list is filtered to only include VMs in scope) Verb get Desc get a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb patch Desc update a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb delete Desc delete a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: vms/start \u00b6 Verb update Desc start a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: vms/stop \u00b6 Verb update Desc stop a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: vms/redeploy \u00b6 Verb update Desc redeploy a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: vms/screenshot \u00b6 Verb get Desc get screenshot for a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: vms/vnc \u00b6 Verb get Desc get VNC address for a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: vms/captures \u00b6 Verb list Desc get list of packet captures for a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb create Desc start a packet capture on a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb delete Desc stop all packet captures on a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: vms/snapshots \u00b6 Verb list Desc get list of snapshots for a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb create Desc create a snapshot of a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb update Desc restore a specific experiment VM to a previous snapshot Exp. Scoped yes Res. Scoped yes Resource: vms/commit \u00b6 Verb create Desc create a new backing image from a specific experiment VM Exp. Scoped yes Res. Scoped yes Resource: applications \u00b6 Verb list Desc get list of user applications Exp. Scoped no Res. Scoped yes (list is filtered to only include applications in scope) Resource: topologies \u00b6 Verb list Desc get list of available topologies Exp. Scoped no Res. Scoped yes (list is filtered to only include topologies in scope) Resource: disks \u00b6 Verb list Desc get list of available backing images Exp. Scoped no Res. Scoped yes (list is filtered to only include backing images in scope) Resource: hosts \u00b6 Verb list Desc get list of minimega cluster hosts Exp. Scoped no Res. Scoped yes (list is filtered to only include hosts in scope) Resource: users \u00b6 Verb list Desc get list of users Exp. Scoped no Res. Scoped yes (list is filtered to only include users in scope) Verb get Desc get a specific user Exp. Scoped no Res. Scoped yes Verb create Desc create a new user Exp. Scoped no Res. Scoped no Verb patch Desc update an existing user Exp. Scoped no Res. Scoped yes Verb delete Desc delete an existing user Exp. Scoped no Res. Scoped yes Built-In Roles \u00b6 See the previous section for policy resource and verb descriptions. case GLOBAL_ADMIN: return Policies([]*Policy{ { Experiments: []string{\"*\"}, Resources: []string{\"*\", \"*/*\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"*\"}, }, }) case GLOBAL_VIEWER: return Policies([]*Policy{ { Experiments: []string{\"*\"}, Resources: []string{\"*\", \"*/*\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\", \"get\"}, }, }) case EXP_ADMIN: // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"experiments\", \"experiments/*\"}, Verbs: []string{\"list\", \"get\", \"update\"}, }, { Resources: []string{\"vms\", \"vms/*\"}, Verbs: []string{\"list\", \"get\", \"create\", \"update\", \"patch\", \"delete\"}, }, { Resources: []string{\"disks\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, { Resources: []string{\"hosts\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, }) case EXP_USER: // EXP_VIEWER + VM restart + VM update + VM capture // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"experiments\", \"experiments/*\"}, Verbs: []string{\"list\", \"get\"}, }, { Resources: []string{\"vms\", \"vms/*\"}, Verbs: []string{\"list\", \"get\", \"patch\"}, }, { Resources: []string{\"vms/redeploy\"}, Verbs: []string{\"update\"}, }, { Resources: []string{\"vms/captures\"}, Verbs: []string{\"create\", \"delete\"}, }, { Resources: []string{\"vms/snapshots\"}, Verbs: []string{\"list\", \"create\", \"update\"}, }, { Resources: []string{\"hosts\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, }) case EXP_VIEWER: // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"experiments\", \"experiments/*\", \"vms\", \"vms/*\"}, Verbs: []string{\"list\", \"get\"}, }, { Resources: []string{\"hosts\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, }) case VM_VIEWER: // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"vms\"}, Verbs: []string{\"list\"}, }, { Resources: []string{\"vms/screenshot\", \"vms/vnc\"}, Verbs: []string{\"get\"}, }, })","title":"User Administration in ph\u0113nix"},{"location":"user-administration/#user-administration-in-phenix","text":"","title":"User Administration in ph\u0113nix"},{"location":"user-administration/#create-a-new-user","text":"There are two primary ways to create new users. Choose the Create Account link off the login page and complete all fields one the Create a New Account dialogue. This will initiate a message to an administrator's account who can then activate the account, setting the role(s) and resource name(s). From the Users tab, click the + button to create a new user. Here the administrator will add the role(s) and resource name(s) .","title":"Create a new user"},{"location":"user-administration/#login","text":"The login page is self-descriptive. Using the Remember me checkbox will set a token to local storage so that you can remove the requirement to enter a Username and Password each time the page or site is reloaded. If an administrator starts the UI server with the following command, authentication is enabled: $> phenix ui -k <some_string> Without the -k (or --jwt-signing-key ), authentication is disabled.","title":"Login"},{"location":"user-administration/#user-administration","text":"","title":"User Administration"},{"location":"user-administration/#updating-users","text":"An administrator is able to click on the username on the table in the Users tab to update a user. They can update First Name or Last Name , Role , Experiment Names , and Resource Name(s) .","title":"Updating Users"},{"location":"user-administration/#roles","text":"Global Admin is the administrator level account and has access to all capabilities, to include user management. Global Admins also have access to all resources. The following table provides a high-level overview of all the available roles and their access rights. Role Limits List Get Create Update Patch Delete Global Admin Can see and control absolutely anything/everything. E V U E V U E V U E V U E V U E V U Global Viewer Can see absolutely anything/everything, but cannot make any changes. E V U E V U Experiment Admin Can see and control anything/everything for assigned experiments, including VMs, but cannot create new experiments. E V E V V E V V V Experiment User Can see assigned experiments, and can control VMs within assigned experiments, but cannot modify experiments themselves. E V E V V Experiment Viewer Can see assigned experiments and VMs within assigned experiments, but cannot modify or control experiments or VMs. E V E V VM Viewer Can only see VM screenshots and access VM VNC, nothing else. V Key: E - experiment resource, V - VM resource, U - user resource","title":"Roles"},{"location":"user-administration/#resources","text":"","title":"Resources"},{"location":"user-administration/#resource-experiments","text":"Verb list Desc get a list of all experiments Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped no Verb get Desc get a specific experiment Exp. Scoped yes Res. Scoped no Verb create Desc create a new experiment Exp. Scoped no Res. Scoped no Verb delete Desc delete a specific experiment Exp. Scoped yes Res. Scoped no","title":"Resource: experiments"},{"location":"user-administration/#resource-experimentsstart","text":"Verb update Desc start an experiment Exp. Scoped yes Res. Scoped no","title":"Resource: experiments/start"},{"location":"user-administration/#resource-experimentsstop","text":"Verb update Desc stop an experiment Exp. Scoped yes Res. Scoped no","title":"Resource: experiments/stop"},{"location":"user-administration/#resource-experimentsschedule","text":"Verb get Desc get current schedule for an experiment Exp. Scoped yes Res. Scoped no Verb create Desc schedule an experiment using schedule algorithm Exp. Scoped yes Res. Scoped no","title":"Resource: experiments/schedule"},{"location":"user-administration/#resource-experimentscaptures","text":"Verb list Desc get list of packet captures for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped yes (list is filtered to only include VMs in scope)","title":"Resource: experiments/captures"},{"location":"user-administration/#resource-experimentsfiles","text":"Verb list Desc get list of files for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped no Verb get Desc get specific experiment file Exp. Scoped yes Res. Scoped no","title":"Resource: experiments/files"},{"location":"user-administration/#resource-vms","text":"Verb list Desc get list of VMs for an experiment Exp. Scoped yes (list is filtered to only include experiments in scope) Res. Scoped yes (list is filtered to only include VMs in scope) Verb get Desc get a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb patch Desc update a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb delete Desc delete a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms"},{"location":"user-administration/#resource-vmsstart","text":"Verb update Desc start a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/start"},{"location":"user-administration/#resource-vmsstop","text":"Verb update Desc stop a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/stop"},{"location":"user-administration/#resource-vmsredeploy","text":"Verb update Desc redeploy a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/redeploy"},{"location":"user-administration/#resource-vmsscreenshot","text":"Verb get Desc get screenshot for a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/screenshot"},{"location":"user-administration/#resource-vmsvnc","text":"Verb get Desc get VNC address for a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/vnc"},{"location":"user-administration/#resource-vmscaptures","text":"Verb list Desc get list of packet captures for a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb create Desc start a packet capture on a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb delete Desc stop all packet captures on a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/captures"},{"location":"user-administration/#resource-vmssnapshots","text":"Verb list Desc get list of snapshots for a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb create Desc create a snapshot of a specific experiment VM Exp. Scoped yes Res. Scoped yes Verb update Desc restore a specific experiment VM to a previous snapshot Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/snapshots"},{"location":"user-administration/#resource-vmscommit","text":"Verb create Desc create a new backing image from a specific experiment VM Exp. Scoped yes Res. Scoped yes","title":"Resource: vms/commit"},{"location":"user-administration/#resource-applications","text":"Verb list Desc get list of user applications Exp. Scoped no Res. Scoped yes (list is filtered to only include applications in scope)","title":"Resource: applications"},{"location":"user-administration/#resource-topologies","text":"Verb list Desc get list of available topologies Exp. Scoped no Res. Scoped yes (list is filtered to only include topologies in scope)","title":"Resource: topologies"},{"location":"user-administration/#resource-disks","text":"Verb list Desc get list of available backing images Exp. Scoped no Res. Scoped yes (list is filtered to only include backing images in scope)","title":"Resource: disks"},{"location":"user-administration/#resource-hosts","text":"Verb list Desc get list of minimega cluster hosts Exp. Scoped no Res. Scoped yes (list is filtered to only include hosts in scope)","title":"Resource: hosts"},{"location":"user-administration/#resource-users","text":"Verb list Desc get list of users Exp. Scoped no Res. Scoped yes (list is filtered to only include users in scope) Verb get Desc get a specific user Exp. Scoped no Res. Scoped yes Verb create Desc create a new user Exp. Scoped no Res. Scoped no Verb patch Desc update an existing user Exp. Scoped no Res. Scoped yes Verb delete Desc delete an existing user Exp. Scoped no Res. Scoped yes","title":"Resource: users"},{"location":"user-administration/#built-in-roles","text":"See the previous section for policy resource and verb descriptions. case GLOBAL_ADMIN: return Policies([]*Policy{ { Experiments: []string{\"*\"}, Resources: []string{\"*\", \"*/*\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"*\"}, }, }) case GLOBAL_VIEWER: return Policies([]*Policy{ { Experiments: []string{\"*\"}, Resources: []string{\"*\", \"*/*\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\", \"get\"}, }, }) case EXP_ADMIN: // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"experiments\", \"experiments/*\"}, Verbs: []string{\"list\", \"get\", \"update\"}, }, { Resources: []string{\"vms\", \"vms/*\"}, Verbs: []string{\"list\", \"get\", \"create\", \"update\", \"patch\", \"delete\"}, }, { Resources: []string{\"disks\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, { Resources: []string{\"hosts\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, }) case EXP_USER: // EXP_VIEWER + VM restart + VM update + VM capture // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"experiments\", \"experiments/*\"}, Verbs: []string{\"list\", \"get\"}, }, { Resources: []string{\"vms\", \"vms/*\"}, Verbs: []string{\"list\", \"get\", \"patch\"}, }, { Resources: []string{\"vms/redeploy\"}, Verbs: []string{\"update\"}, }, { Resources: []string{\"vms/captures\"}, Verbs: []string{\"create\", \"delete\"}, }, { Resources: []string{\"vms/snapshots\"}, Verbs: []string{\"list\", \"create\", \"update\"}, }, { Resources: []string{\"hosts\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, }) case EXP_VIEWER: // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"experiments\", \"experiments/*\", \"vms\", \"vms/*\"}, Verbs: []string{\"list\", \"get\"}, }, { Resources: []string{\"hosts\"}, ResourceNames: []string{\"*\"}, Verbs: []string{\"list\"}, }, }) case VM_VIEWER: // must supply experiment names and resource names or nothing will authorize return Policies([]*Policy{ { Resources: []string{\"vms\"}, Verbs: []string{\"list\"}, }, { Resources: []string{\"vms/screenshot\", \"vms/vnc\"}, Verbs: []string{\"get\"}, }, })","title":"Built-In Roles"},{"location":"vms/","text":"VMs \u00b6 VM Info \u00b6 From the Web-UI \u00b6 The experiment must be started; click on the experiment name to enter the Running Experiment component. Within that component, click on the VM name and you will be presented with a VM information modal. Available commands restore a snapshot by clicking the play button next to the desired snapshot name. Buttons from left to right on the footer of modal: * pause a running VM with the pause button * Create a snapshot of a running VM with the camera button * Create a backing image of a running VM with the floppy disk button * redeploy a running VM with the yellow power button * kill a running VM with the trash can From the Command Line Binary \u00b6 There are two options for displaying the information for VMs in an experiment. First run the following command to see information for all VMs in a given experiment. $> phenix vm info <experiment name> Or, run the following to see the information for a specific VM in an experiment. $> phenix vm info <experiment name> <vm name> Packet Capture \u00b6 From the Web-UI \u00b6 Click on the name of the network tap on a running VM in a started experiment to start a packet capture. The name of the network tap will turn green once a packet capture has started. It is possible to start captures on multiple network taps. However, when you stop packet capture, it will stop captures on all network taps. From the Command Line Binary \u00b6 To start a packet capture, run the following command. $> phenix vm capture start <experiment name> <vm name> <iface index> </path/to/out file> To stop all packet captures on a running VM, use the following command. $> phenix vm capture stop <experiment name> <vm name> Kill a VM \u00b6 From the Web-UI \u00b6 Click on a running VM in a started experiment to access the VM information modal. The red trash can icon to the far right of the modal footer will kill that VM. Note : if you stop and then start the experiment again, that VM will run again per the experiment configuration. From the Command Line Binary \u00b6 To kill a VM, run the following command. $> phenix vm kill <experiment name> <vm name> Modify the Network Connectivity \u00b6 From the Web-UI \u00b6 Click on the network for the desired VM in the Running Component to modify the settings. Select from a pull down what network you want to switch the VM interface you clicked on to. To revert back to previous setting, simply repeat selecting the network interface you wish to change, and select the previous network setting. From the Command Line Binary \u00b6 To connect a VM network interface to a different network, run the following command. $> phenix vm net connect <experiment name> <vm name> <iface index> <vlan id> To disconnect a VM network interface, run the following command. $> phenix vm net disconnect <experiment name> <vm name> <iface index> Pause a VM \u00b6 From the Web-UI \u00b6 Click on the name of a running VM in a started experiment to access the VM information modal. To pause a VM, click on the pause button (pause button, furthest button to the left). To start a paused VM, that same button will become a green play button; simply click it to start. From the Command Line Binary \u00b6 To pause a VM, run the following command. $> phenix vm pause <experiment name> <vm name> To resume a paused VM, run the following command. $> phenix vm resume <experiment name> <vm name> Redeploy a VM \u00b6 From the Web-UI \u00b6 Click on the name of a running VM in a started experiment to access the VM information modal. To redeploy a VM, click on the redeploy button (yellow power button, second from the right). You will be able to modify the settings for CPU, Memory, Disk, and whether to replicate original injections before you redeploy the VM. From the Command Line Binary \u00b6 To redploy a VM, run the following command. $> phenix vm redeploy <experiment name> <vm name> Resume a VM \u00b6 From the Web-UI \u00b6 Click on the name of the paused VM in a started experiment to access the VM information modal. Click the green play button (previously the pause button, furthest button to the left). From the Command Line Binary \u00b6 To resume a paused VM, run the following command. $> phenix vm resume <experiment name> <vm name> Modify VM Settings \u00b6 From the Web-UI \u00b6 There are two ways to modify VM settings: 1. Click on a stopped experiment to access the Stopped Component. You are able to edit the following: * Host name * CPUs * Memory * Disk * Do not boot flag 2. From a running experiment, click on the VM name and then the redeploy button (yellow power button, second from the right on the modal footer). You are able to edit the following: * CPU * Memory * Disk * Replication of original injections From the Command Line Binary \u00b6 This command is not yet implemented. For now, you can edit the stopped experiment directly with the following command. $> phenix cfg edit topology/<topology name> This will launch the system editor where you can directly modify the experiment settings.","title":"VMs"},{"location":"vms/#vms","text":"","title":"VMs"},{"location":"vms/#vm-info","text":"","title":"VM Info"},{"location":"vms/#from-the-web-ui","text":"The experiment must be started; click on the experiment name to enter the Running Experiment component. Within that component, click on the VM name and you will be presented with a VM information modal. Available commands restore a snapshot by clicking the play button next to the desired snapshot name. Buttons from left to right on the footer of modal: * pause a running VM with the pause button * Create a snapshot of a running VM with the camera button * Create a backing image of a running VM with the floppy disk button * redeploy a running VM with the yellow power button * kill a running VM with the trash can","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary","text":"There are two options for displaying the information for VMs in an experiment. First run the following command to see information for all VMs in a given experiment. $> phenix vm info <experiment name> Or, run the following to see the information for a specific VM in an experiment. $> phenix vm info <experiment name> <vm name>","title":"From the Command Line Binary"},{"location":"vms/#packet-capture","text":"","title":"Packet Capture"},{"location":"vms/#from-the-web-ui_1","text":"Click on the name of the network tap on a running VM in a started experiment to start a packet capture. The name of the network tap will turn green once a packet capture has started. It is possible to start captures on multiple network taps. However, when you stop packet capture, it will stop captures on all network taps.","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary_1","text":"To start a packet capture, run the following command. $> phenix vm capture start <experiment name> <vm name> <iface index> </path/to/out file> To stop all packet captures on a running VM, use the following command. $> phenix vm capture stop <experiment name> <vm name>","title":"From the Command Line Binary"},{"location":"vms/#kill-a-vm","text":"","title":"Kill a VM"},{"location":"vms/#from-the-web-ui_2","text":"Click on a running VM in a started experiment to access the VM information modal. The red trash can icon to the far right of the modal footer will kill that VM. Note : if you stop and then start the experiment again, that VM will run again per the experiment configuration.","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary_2","text":"To kill a VM, run the following command. $> phenix vm kill <experiment name> <vm name>","title":"From the Command Line Binary"},{"location":"vms/#modify-the-network-connectivity","text":"","title":"Modify the Network Connectivity"},{"location":"vms/#from-the-web-ui_3","text":"Click on the network for the desired VM in the Running Component to modify the settings. Select from a pull down what network you want to switch the VM interface you clicked on to. To revert back to previous setting, simply repeat selecting the network interface you wish to change, and select the previous network setting.","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary_3","text":"To connect a VM network interface to a different network, run the following command. $> phenix vm net connect <experiment name> <vm name> <iface index> <vlan id> To disconnect a VM network interface, run the following command. $> phenix vm net disconnect <experiment name> <vm name> <iface index>","title":"From the Command Line Binary"},{"location":"vms/#pause-a-vm","text":"","title":"Pause a VM"},{"location":"vms/#from-the-web-ui_4","text":"Click on the name of a running VM in a started experiment to access the VM information modal. To pause a VM, click on the pause button (pause button, furthest button to the left). To start a paused VM, that same button will become a green play button; simply click it to start.","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary_4","text":"To pause a VM, run the following command. $> phenix vm pause <experiment name> <vm name> To resume a paused VM, run the following command. $> phenix vm resume <experiment name> <vm name>","title":"From the Command Line Binary"},{"location":"vms/#redeploy-a-vm","text":"","title":"Redeploy a VM"},{"location":"vms/#from-the-web-ui_5","text":"Click on the name of a running VM in a started experiment to access the VM information modal. To redeploy a VM, click on the redeploy button (yellow power button, second from the right). You will be able to modify the settings for CPU, Memory, Disk, and whether to replicate original injections before you redeploy the VM.","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary_5","text":"To redploy a VM, run the following command. $> phenix vm redeploy <experiment name> <vm name>","title":"From the Command Line Binary"},{"location":"vms/#resume-a-vm","text":"","title":"Resume a VM"},{"location":"vms/#from-the-web-ui_6","text":"Click on the name of the paused VM in a started experiment to access the VM information modal. Click the green play button (previously the pause button, furthest button to the left).","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary_6","text":"To resume a paused VM, run the following command. $> phenix vm resume <experiment name> <vm name>","title":"From the Command Line Binary"},{"location":"vms/#modify-vm-settings","text":"","title":"Modify VM Settings"},{"location":"vms/#from-the-web-ui_7","text":"There are two ways to modify VM settings: 1. Click on a stopped experiment to access the Stopped Component. You are able to edit the following: * Host name * CPUs * Memory * Disk * Do not boot flag 2. From a running experiment, click on the VM name and then the redeploy button (yellow power button, second from the right on the modal footer). You are able to edit the following: * CPU * Memory * Disk * Replication of original injections","title":"From the Web-UI"},{"location":"vms/#from-the-command-line-binary_7","text":"This command is not yet implemented. For now, you can edit the stopped experiment directly with the following command. $> phenix cfg edit topology/<topology name> This will launch the system editor where you can directly modify the experiment settings.","title":"From the Command Line Binary"}]}